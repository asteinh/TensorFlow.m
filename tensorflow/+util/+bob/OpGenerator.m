classdef OpGenerator < util.mixin.Base
  %OPGENERATOR Summary of this class goes here
  %   Detailed explanation goes here

%TODO implement the following fields:
%   deprecation
%   is_aggregate
%   is_stateful
%   is_commutative
%   allows_uninitialized_input
%   control_output
%   unknown_fields
%   descriptor_function

  properties
    s = struct();
    id = '';
  end

  methods
    function obj = OpGenerator(s)
      assert(isstruct(s));
      obj.s = s;
      obj.id = lower(obj.s.name);
    end

    function generateFunction(obj, output_folder)
      txt = obj.gen_INIT_();

      % generate input_arg
      txt = obj.lb(txt);
      for i = 1:numel(obj.s.input_arg)
        txt = [ txt; obj.gen_input_arg_(i, obj.s.input_arg(i)) ];
        txt = obj.lb(txt);
      end

      % generate attr
      for i = 1:numel(obj.s.attr)
        txt = [ txt; obj.gen_attr_(i, obj.s.attr(i))];
        txt = obj.lb(txt);
      end

      txt = [ txt; obj.gen_EXIT_() ];

      file = fullfile(output_folder, [obj.id '.m']);
      fid = fopen(file, 'w');
      fprintf(fid, '%s\n', txt{:});
      fclose(fid);
    end
  end

  methods (Access=private)
    function txt = gen_INIT_(obj)
      % summary
      txt = { [ '%' upper(obj.id) ' ' obj.s.summary] };
      % description
      for line = splitlines(obj.s.description)'
        txt = [ txt;  [ '%   ' line{:} ] ];
      end
      txt = obj.lb(txt);

      % notice
      txt = [ txt;
        [ '% <auto-generated>' ];
        [ '%   Generated by OpGenerator of tensorflow.m. DO NOT EDIT!' ];
        [ '%   Source OpDef: ' obj.s.name ];
        [ '% </auto-generated>' ];
      ];
      txt = obj.lb(txt);

      % header
      txt = [ txt; [ 'function out = ' obj.id '(graph, varargin)' ] ];

      % process input arguments
      ninputs = numel(obj.s.input_arg);
      txt = [ txt;
        [ '  assert(nargin >= ' num2str(ninputs+1) ', ''Not enough input arguments.'');' ];
        [ '  assert(nargin <= ' num2str(ninputs+2) ', ''Too many input arguments.'');' ];
        { ' ' };
        [ '  if nargin == ' num2str(ninputs+2) ];
        [ '    op_name = varargin{' num2str(ninputs+2) '}; ' ];
        [ '    assert(ischar(op_name), ''Provided Operation name must be a string.''); ' ];
        [ '  else' ];
        [ '    [~, randkey] = util.KeyGen.sha1();' ];
        [ '    op_name = [ ''' obj.s.name '_''' ' randkey ];' ];
        [ '  end' ];
        { ' ' };
      ];

      % assertions
      txt = [ txt; [ '  assert(isa(graph, ''tensorflow.Graph''), ''First input argument must be of class tensorflow.Graph.'');' ] ];
      % op description
      txt = [ txt; [ '  desc = graph.newOperation(''' obj.s.name ''', op_name);' ] ];
    end

    function txt = gen_input_arg_(obj, i, input_arg)
      name = input_arg.name;
      txt = {
        [ '  ' name ' = varargin{' num2str(i) '};' ];
        [ '  assert(isa(' name ', ''tensorflow.Output''), ''Inputs must be of class tensorflow.Output.'');' ];
        [ '  desc.addInput(' name ');' ]
      };
    end

    function txt = gen_attr_(obj, i, attr)
      % assert()
      % desc.setAttr*
      txt = { '  % TODO codegen attributes'};
    end

    function txt = gen_EXIT_(obj)
      txt = {
        [ '  out = tensorflow.Output(desc.finishOperation());' ];
        [ 'end' ];
      };
    end
  end

  methods (Static)
    function txt = lb(txt)
      txt = [ txt; { ' ' } ];
    end
  end
end
